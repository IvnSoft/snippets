#!/usr/bin/env perl
package App::ps;
use strict;
use warnings;

# accessors
sub argv      { @{shift->{argv}} }
sub bin       { $ENV{PS_BIN} || '/bin/ps' }
sub system_ps { $^O ne 'darwin' ? 1 : !$_[0]->{has_f} }

# methods
sub make_tree {
  my $self = shift;
  @$self{qw(heading root tree)} = ('', undef, {});

  open my $PS, '-|', $self->bin, $self->argv or die "[App:ps] Could not run ps: $!";
  while (<$PS>) {
    chomp;
    warn "[App::ps] invalid = $_\n" and next unless s!^\s*(\w+)\s+(\w+)!!;    # pid,ppid,...
    warn "[App::ps] out = $_\n" if $ENV{PS_DEBUG};
    my ($pid, $ppid, $out) = ($1, $2, $_);

    # Parse heading PID, PPID, ...
    unless ($pid =~ /^\d+$/) {
      $self->{heading} = $out;
      my @chunks = $out =~ m!(\s*\w+\s+)!g;
      my $len = 0;
      $len += length $chunks[$_] for 0 .. (@chunks - 1);
      $self->{re} = qr/^(.{$len})(.*)/;
      next;
    }

    # Create process tree
    $self->{tree}{$pid}{out} = [$out =~ $self->{re}];
    $self->{tree}{$pid}{pid} = $pid;
    push @{$self->{tree}{$ppid}{kids}}, $self->{tree}{$pid};
    $self->{root} ||= $self->{tree}{$ppid};
  }

  return $self;
}

sub normalize_argv {
  my $self = shift;
  my @argv = $self->argv;

  @$self{qw(has_f has_o has_w)} = (0, -1, 0);

  # Check if we have "f", "-f" or something in the command
  for (@argv) {
    $self->{has_f} = 1 if s!(-*\w*)f(.*)!$1$2!g;
  }

  return $self unless $self->{has_f};

  # Check if we have "o", "-o" or something in the command
  for my $i (0 .. (@argv - 1)) {
    $self->{has_o} = $i if $argv[$i]            =~ m!^-?o!;
    $self->{has_o} = -2 if $i == 0 && $argv[$i] =~ s!^([^o]*)o(\w*)$!$1$2!;
    $self->{has_w} += length $2 if $argv[$i] =~ s!(-*[^w]*)(w+)(.*)!$1$3!g;
  }

  # Add default format or prepend -o with "ppid"
  no warnings 'qw';
  if ($self->{has_o} == -1) {
    push @argv, qw(-o pid,ppid,pid,tty,stat,time,command);
  }
  elsif ($self->{has_o} == -2) {
    splice @argv, 1, 0, qw(-o pid,ppid -o);
  }
  else {
    splice @argv, $self->{has_o}, 0, qw(-o pid,ppid);
  }

  @argv = grep length, @argv;
  warn "[App::ps] argv = @argv\n" if $ENV{PS_DEBUG};
  $self->{argv} = [@argv];

  return $self;
}

sub print_tree {
  my $self   = shift;
  my $nodes  = shift || $self->{root}{kids} || [];
  my $indent = shift || 0;

  printf "%s\n", $self->{heading} if !$indent and length $self->{heading};

  for my $node (@$nodes) {
    my @out = @{$node->{out} || []};
    unshift @out, '' if @out == 1;

    my $tree_prefix = ' ' x ($indent ? ($indent * 4) - 2 : 0);
    $tree_prefix .= '\\_ ' if $indent;
    my $line = sprintf "%s%s%s", $out[0] // '', $tree_prefix, $out[1] // '';

    my $cols
      = $self->{has_w} == 1 ? 132
      : $self->{has_w} >= 2 ? length $line
      : $ENV{COLUMNS} || length $line;
    printf "%s\n", substr $line, 0, $cols;

    $self->print_tree($node->{kids}, $indent + 1) if $node->{kids};
  }
}

sub run {
  my $self = shift;

  # Run unit tests
  return $self->test if grep /^--test/, $self->argv;

  # Execute native ps
  exec $self->bin, $self->argv if $self->system_ps;

  # Print tree (-f)
  require Term::ReadKey;
  $ENV{COLUMNS} ||= (Term::ReadKey::GetTerminalSize())[0];
  $self->make_tree->print_tree;

  # Exit
  return $? || $! || 0;
}

sub test {
  no warnings 'qw';

  # (@argv, [$has_f, $has_o, @ps_argv], 'description')
  test_ok([],                    [qw(0 -1)],                       'ps');
  test_ok(['ax'],                [qw(0 -1 ax)],                    'ps ax');
  test_ok(['-xfa', '-o', 'cpu'], [qw(1 1 -xa -o pid,ppid -o cpu)], 'ps -xfa -o cpu');
  test_ok(['fao', 'cpu'],        [qw(1 -2 a -o pid,ppid -o cpu)],  'ps fao cpu');
  test_ok(['fo', 'ppid'],        [qw(1 -2 -o pid,ppid -o ppid)],   'ps fo ppid');
  test_ok(['axf'],               [qw(1 -1 ax -o pid,ppid,pid,tty,stat,time,command)], 'ps axf');

  Test::More::done_testing();
  return 0;
}

sub test_ok {
  require Test::More;
  my $argv = shift;
  my $app  = App::ps->new(@$argv)->normalize_argv;
  Test::More::is_deeply([$app->{has_f}, $app->{has_o}, $app->argv], @_)
    or Test::More::diag(join ' ', $app->argv);
}

# constructor
sub new {
  my ($class, @argv) = @_;
  return bless {argv => [@argv]}, $class;
}

my $app = App::ps->new(@ARGV)->normalize_argv->run;

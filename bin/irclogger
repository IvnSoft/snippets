#!/usr/bin/env perl
use Mojolicious::Lite;
use Mojo::IRC::UA;
use Mojo::Pg;
use Mojo::Util 'md5_sum';
use Parse::IRC;
use Time::Piece;

use constant RECONNECT_TIMEOUT => $ENV{LOGMAN_RECONNECT_TIMEOUT} || 6;

$ENV{LOGMAN_PG_URL} ||= sprintf 'postgresql://%s@/logman_%s', (getpwuid $<)[0] || 'postgresql', app->mode;
$ENV{LOGMAN_SECRET} ||= md5_sum(time . rand . $$ . $ENV{LOGMAN_SECRET});

warn "LOGMAN_SECRET: $ENV{LOGMAN_SECRET}\n";

my $pg   = Mojo::Pg->new($ENV{LOGMAN_PG_URL});
my $bots = {};

get '/' => sub {
  my $c = shift;
  $c->render(text => sprintf "Usage: %s:server/:channel\n", $c->req->url->to_abs);
};

get '/#server/:channel' => sub {
  my $c       = shift;
  my $server  = $c->stash('server');
  my $channel = '#' . $c->stash('channel');
  my @where   = ('m.server = ?', 'm.channel = ?', 'id > ?');
  my @bind    = ($server, $channel, $c->param('id') || 0);

  if ($c->param('q')) {
    push @where, 'm.message LIKE ?';
    push @bind, sprintf '%%%s%%', $c->param('q');
  }

  $c->delay(
    sub {
      my ($delay) = @_;
      @where = (join ' AND ', @where);
      $c->db(<<"      SQL", @bind, $delay->begin);
      SELECT
        m.id      AS id,
        m.ts AT TIME ZONE 'UTC' AS ts,
        m.type    AS type,
        m.nick    AS nick,
        m.message AS message
      FROM logman_messages m
      WHERE @where
      ORDER BY id
      LIMIT 60
      SQL
    },
    sub {
      my ($delay, $err, $res) = @_;
      die $err if $err;
      return $c->render('log', messages => $res->hashes) if $res->rows > 0 or $c->param('q');
      $c->db(<<'      SQL', $server, $channel, $delay->begin);
        SELECT ch.id
        FROM logman_channels ch
        LEFT JOIN logman_connections co ON co.id = ch.id_server
        WHERE co.server = ? AND ch.channel = ?
      SQL
    },
    sub {
      my ($delay, $err, $res) = @_;
      return $c->render('log', messages => []) if $res->rows > 0;
      return $c->render('add');
    },
  );
};

post '/#server/:channel' => sub {
  my $c          = shift;
  my $server     = $c->stash('server');
  my $channel    = '#' . $c->stash('channel');
  my $validation = $c->validation;
  my $output;

  $validation->required('secret')->in($ENV{LOGMAN_SECRET});
  $validation->optional('port')->like(qr{^\d+$});
  $validation->optional('nick')->like(qr{^[\w_-]+$});
  $validation->has_error and return $c->render('add');
  $output = $validation->output;
  $output->{channel} = $channel;
  $output->{nick} ||= 'wooden_axis';
  $output->{port} ||= 6667;
  $output->{server} = $server;

  $c->delay(
    sub {
      my ($delay) = @_;
      $c->db(
        'INSERT INTO logman_connections (server, port, nick) VALUES (?, ?, ?)',
        @$output{qw( server port nick )},
        $delay->begin
      );
    },
    sub {
      my ($delay, $err, $res) = @_;
      _abort_unless_duplicate($err, $res);
      $c->db(
        'INSERT INTO logman_channels (id_server, channel) VALUES ((SELECT id FROM logman_connections WHERE server=?), ?)',
        $server, $channel, $delay->begin);
    },
    sub {
      my ($delay, $err, $res) = @_;
      _abort_unless_duplicate($err, $res);
      $output->{channels} = [$output->{channel}];
      $c->join_channel($output);
      $c->redirect_to($c->req->url);
    },
  );
};

websocket '/#server/:channel/stream' => sub {
  my $c   = shift;
  my $bot = $c->bot or return $c->finish;
  my $channel = $c->stash('channel');
  my ($cb, $tid);

  $tid = Mojo::IOLoop->recurring(10 => sub { $c->send("<!-- keep alive -->\n"); });

  $cb = $bot->on(message => sub {
    my ($bot, $m) = @_;
    return if $channel eq $m->{channel};
    $c->send($c->render_to_string('message', m => $m));
  });

  $c->on(
    finish => sub {
      $bot->unsubscribe($cb);
      Mojo::IOLoop->remove($tid);
    }
  );
};

helper bot => sub {
  my $c = shift;
  my $server = shift || $c->stash('server');
  return $bots->{$server};
};

helper db => sub {
  my $c = shift;
  my $db = $c->stash->{db} ||= $pg->db;
  return $db->query(@_) if @_;
  return $db;
};

helper join_channel => sub {
  my ($c, $args) = @_;
  my $bot = $c->bot($args->{server});

  if ($bot) {
    return unless @{$args->{channels}};
    return $bot->join_channel(shift @{$args->{channels}}, sub { $c->join_channel($args); });
  }

  $bot = $bots->{$args->{server}} = Mojo::IRC::UA->new(tls => {}, %$args);
  $bot->server("$args->{server}:$args->{port}");
  $bot->parser(Parse::IRC->new(ctcp => 1));

  $bot->connect(
    sub {
      my ($bot, $err) = @_;

      $c->app->log->warn("[$args->{server}] $err") if $err;

      if ($err =~ /IO::Socket::SSL/ or $err =~ /SSL.*HELLO/) {
        delete $bots->{$args->{server}};
        $args->{tls} = undef;
        Mojo::IOLoop->timer(RECONNECT_TIMEOUT, sub { $c->join_channel($args) });
      }
      elsif ($err) {
        $bot->{error} = $err;
      }
      else {
        $c->join_channel($args);
        for my $type (qw( ctcp_action irc_notice irc_privmsg )) {
          $bot->on($type => sub { _log($_[0], $type, $_[1]) });
        }
      }
    }
  );
};

hook before_dispatch => sub {
  my $this = shift;
  if (my $base = $this->req->headers->header('X-Request-Base')) {
    $this->req->url->base(Mojo::URL->new($base));
  }
};

$pg->migrations->name('logman')->from_data->migrate;
_connect();
app->start;

sub _abort_unless_duplicate {
  my ($err, $res) = @_;

  # unique_violation, http://www.postgresql.org/docs/9.3/static/errcodes-appendix.html
  die $err if $err and !$res->sth->state == 23505;
}

sub _connect {
  my $connections = $pg->db->query('SELECT id, server, port, nick FROM logman_connections');

  for my $args ($connections->hashes->each) {
    my $channels = $pg->db->query('SELECT channel FROM logman_channels WHERE id_server = ?', $args->{id});
    $args->{channels} = $channels->hashes->map(sub { $_->{channel} })->to_array;
    app->join_channel($args);
  }
}

sub _log {
  my ($bot, $type, $msg) = @_;
  my ($nick, $user, $host) = IRC::Utils::parse_user($msg->{prefix} || '');
  my $m = {channel => $msg->{params}[0] || '', message => $msg->{params}[1] || '', nick => $nick, type => $type};

  return unless $m->{channel} =~ /^[&#]/;

  $bot->emit(message => $m);
  $pg->db->query(
    <<'  SQL', $bot->{server} =~ /^([^:]+)/ ? $1 : undef, @$m{qw( channel type nick message )});
  INSERT INTO logman_messages
  (server, channel, type, nick, message)
  VALUES (?, ?, ?, ?, ?)
  SQL
}

__DATA__
@@ add.html.ep
% layout 'default';
% title 'Add new channel to log';
% my $bot = bot;
% my @readonly = (readonly => 'readonly');

<div class="add">
  %= form_for '', method => 'post', class => 'pure-form pure-form-stacked', begin
    <h1>Requested channel not logged</h1>
    <fieldset>
      <legend>Connection details</legend>

      <div class="pure-g">
        <div class="pure-u-2-3">
          <label for="form_server">Server</label>
          %= text_field 'server', $server, @readonly, class => "pure-u-23-24"
        </div>
        <div class="pure-u-1-3">
          <label for="form_port">Port</label>
          %= text_field 'port', +($bot ? $bot->server =~ /:(\d+)/ || 6667 : 6667), $bot ? @readonly : (), class => "pure-u-1"
        </div>
      </div>

      <div class="pure-g">
        <div class="pure-u-2-3">
          <label for="form_nick">Nick</label>
          %= text_field 'nick', +($bot ? $bot->nick : 'wooden_axis'), $bot ? @readonly : (), class => "pure-u-23-24"
        </div>
      </div>

      <div class="pure-g">
        <div class="pure-u-2-3">
          <label for="form_channel">Channel</label>
          %= text_field 'channel', "#$channel", @readonly, id => 'form_channel', class => "pure-u-23-24"
        </div>
      </div>

      <div class="pure-g">
        <div class="pure-u-1">
          <label for="form_secret">Secret</label>
          %= password_field 'secret', id => 'form_secret', class => "pure-u-1"
        </div>
      </div>

      <br>
      <button type="submit" class="pure-button pure-button-primary">Log channel</button>
    </fieldset>
  % end
</div>

@@ log.html.ep
% layout 'default';
% title "Log for #$channel on $server";

<div class="navbar">
  %= form_for '', class => 'pure-form inner', begin
    <button type="submit" class="pure-button pure-button-primary">Search</button>
    <h1>Log for #<%= $channel %> on <%= $server %></h1>
    %= text_field 'q', class => 'pure-u-3-4'
  % end
</div>

<div class="conversation">
  <ul>
  % for my $m (@$messages) {
    %= include 'message', m => $m
  % }
  % unless (@$messages) {
    <p>Could not find any messages matching "<%= param 'q' %>".</p>
  % }
  </ul>
</div>

@@ message.html.ep
% my $ts = $m->{ts} ? Time::Piece->strptime($m->{ts}, '%Y-%m-%d %H:%M:%S') : Time::Piece->gmtime;
<li>
  <h4><%= $m->{nick} %></h4>
  <span class="ts" title="<%= $ts->datetime %>"><%= $ts->hms %></span>
  <div class="message"><%= $m->{message} %></div>
</li>

@@ layouts/default.html.ep
<html>
  <head>
    <title><%= title %></title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    %= stylesheet begin
      .add {
        margin: 3em auto;
        max-width: 30em;
      }
      .add .pure-form-stacked .field-with-error {
        background: #fee;
        border-color: #900;
      }
      .navbar {
        background: #ffffff;
        box-shadow: 0 12px 12px 12px #fff;
        padding-top: 1em;
        position: fixed;
        top: 0;
        right: 0;
        left: 0;
        z-index: 10;
      }
      .navbar .inner {
        max-width: 44em;
        margin: 0 auto;
      }
      .navbar .inner h1 {
        font-size: 1.8em;
        color: #444;
        margin: 0;
        padding: 0;
      }
      .navbar .pure-form input {
        display: none;
      }
      .navbar button {
        float: right;
      }
      .conversation ul {
        list-style: none;
        max-width: 44em;
        margin: 0 auto;
        padding: 4em 0 1em 0;
      }
      .conversation li {
        margin: 0.4em 0;
        clear: both;
      }
      .conversation h4 {
        color: #38c;
        margin: 0.8em 0 0.4em 0;
        padding: 0;
      }
      .conversation .day-changed div {
        border-top: 2px dotted #ddd;
        margin-top: 2em;
        text-align: center;
        color: #444;
      }
      .conversation .day-changed span {
        background: #fff;
        position: relative;
        top: -0.57em;
        padding: 0 0.5em;
      }
      .conversation .ts {
        font-size: 0.9em;
        color: #777;
        float: right;
      }
    % end
  </head>
  <body>
  %= content
  %= javascript 'https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js'
  %= javascript begin
  var dateExt = ['th', 'st', 'nd', 'rd'];
  var first = {nick: '', ymd: ''};
  var last = {nick: '', ymd: ''};
  var ws;

  var follow = function() {
    ws = new WebSocket('<%= url_for("/$server/$channel/stream")->to_abs =~ s!^http!ws!r %>');
    ws.onclose = function() { setTimeout(follow, 5000); };
    ws.onmessage = function(e) {
      if (e.data.match(/<!--/)) return;
      var $li = $(e.data);
      $('.conversation ul').append($li);
      renderMessages($li);
    };
  };

  var renderMessages = function($li) {
    var month = ['Januar', 'Februar', 'March', 'April', 'Mai', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

    $li.not('.rendered').each(function() {
      var $li = $(this);
      var $h4 = $('h4', this);
      var $ts = $('.ts', this);
      var ts = new Date($ts.attr('title') + '+0000');
      var ymd = [ts.getYear(), ts.getMonth(), ts.getDate()].join('-');
      var s;

      if (ymd != last.ymd) {
        s = ts.getDate() + (dateExt[ts.getDate()] || dateExt[0]);
        s += " of " + month[ts.getMonth()];
        s += ", " + ts.getFullYear();
        $(this).before('<li class="day-changed rendered"><div><span>' + s + '</span></div>');
        last.ymd = ymd;
        last.nick = '';
      }

      if ($h4.text() == last.nick) {
        $h4.hide();
      }

      $ts.text([ts.getHours(), ts.getMinutes(), ts.getSeconds()].map(function(i) { return i < 10 ? '0' + i : i; }).join(':'));
      $li.addClass('rendered');
      last.nick = $h4.text();
    });
  };

  $(document).ready(function() {
  % unless (param 'q') {
    follow();
  % }
    renderMessages($('.conversation li'));
    $('body').scrollTop($('body').height());
    $('.navbar input').keydown(function(e) {
      if (e.keyCode != 27) return;
      $(this).hide();
      $('.navbar h1').show();
    });
    $('.navbar button').click(function(e) {
      var $input = $('.navbar input');
      if ($input.is(':visible')) return;
      e.preventDefault();
      $('.navbar h1').hide();
      $input.show().focus();
    });
  });
  % end
  <body>
</html>

@@ logman
-- 1 up
CREATE TABLE IF NOT EXISTS logman_connections (
  id     SERIAL PRIMARY KEY,
  server TEXT NOT NULL UNIQUE,
  port   INTEGER NOT NULL,
  nick   TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS logman_channels (
  id        SERIAL PRIMARY KEY,
  id_server INTEGER REFERENCES logman_connections (id),
  channel   VARCHAR(128),
  UNIQUE (id_server, channel)
);

CREATE TABLE IF NOT EXISTS logman_messages (
  id      SERIAL PRIMARY KEY,
  server  TEXT NOT NULL,
  channel VARCHAR(128),
  ts      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  type    VARCHAR(32) NOT NULL,
  nick    TEXT NOT NULL,
  message TEXT NOT NULL
);

-- 1 down
DROP TABLE IF EXISTS logman_messages;
DROP TABLE IF EXISTS logman_channels;
DROP TABLE IF EXISTS logman_connections;

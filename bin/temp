#!/usr/bin/perl
use strict;
use warnings;
use feature qw(say state);
use experimental 'signatures';
use IO::Socket::INET;
use Time::Piece;

my ($csv) = grep { /-csv/ } @ARGV;
my ($interval) = grep { /^\d+$/ } @ARGV, 60;
my $len = 0;
my %temp;

local $| = 1; # autoflush
while (1) {
  read_sensors();
  read_hddtemp();
  $csv ? print_summary_csv() : print_summary_human();
  last unless $csv;
  sleep $interval;
}

sub name($str) {
  my $l = length $str;
  $len = $l if $l > $len;
  return lc $str;
}

sub print_summary_csv {
  state $print_headers = 0;
  say join ',', 'time', sort keys %temp unless $print_headers++;
  say join ',', localtime->datetime, map { $temp{$_} } sort keys %temp;
}

sub print_summary_human() {
  for my $k (sort { $temp{$b} <=> $temp{$a} } keys %temp) {
    printf "%-${len}s = %sC\n", $k, $temp{$k};
  }
}

sub read_hddtemp {
  my $HDDTEMP = IO::Socket::INET->new(PeerAddr => 'localhost:7634') or die "hddtemp: $!";
  my $hddtemp = '';
  while (1) {
    $HDDTEMP->recv(my $buf, 1024);
    $hddtemp .= $buf || last;
  }

  my ($p, $name) = (0, '');
  for my $part (split /\|/, $hddtemp) {
    $name = $part =~ m!/dev/(\w+)! ? $1 : $name if ($p % 5) == 1;
    $temp{name($name)} = $part if ($p % 5) == 3;
    $p++;
  }
}

sub read_sensors {
  open my $SENSORS, '-|', 'sensors' or die "sensors: $!";
  while (<$SENSORS>) {
    my ($name, $temp) = /^(.+):\s+\+(\d+)/ or next;
    next if $name =~ m!package!i;
    $name =~ s!\s+!!g;
    $temp{name($name)} = $temp;
  }
}
